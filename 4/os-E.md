オペレーティング・システム
===

# 1章 オペレーティングシステム
## 1.1 ハードウェアとソフトウェア

- ハードウェア: 計算などの処理を行う実態 + 入出力
- ソフトウェア: 処理状況やデータ
  - 補助記憶装置に置かれる
  - **主記憶**にロードして、CPUが実行する
    - 論理アドレスとして扱われることが多い

### オペレーティングシステムとは
ハードウェアの操作、管理を行い、最も基本的な機能を提供するプログラム体型（ソフトウェアシステム）のこと

- アプリケーションプログラム
一般のユーザーが各自の仕事を処理するために用いるプログラム
- システムプログラム
汎用性の高いサービスを提供するためのプログラム
  - コンパイラ、ウィンドウシステム…

計算機の処理は階層構造をなしている

## 1.2 OSの基本機能

### OSの役割
- ハードウェアに依存した細かな操作を代行し、ハードウェアを抽象化する
- ハードウェア資源とソフトウェア資源の管理
- - 各資源を正しく、効率よく利用するための管理を行う

### OSの処理方式


>- ユニプログラミング
>同時に1つしかプログラムを実行しない処理方式
>- マルチプログラミング
>同時に複数のプログラムを実行できる処理方式
>CPUの数とは無関係


>- シングルユーザOS
>同時には1人のユーザーのみ利用可能
>マルチユーザOS
>同時に複数のユーザが利用可能

### OSの構造
マルチプログラミングには
- 多重化の技術が必要
  各々のプログラムにとって、専用の資源が存在するように見せかける手法
  > - 時分割: 時間を区切って資源を割り当てる
  > - 空間分割: 空間（容量）を区切って資源を割り当てる

### システム性能の評価
- 応答時間
  処理要求から応答が帰ってくるまでの時間
  短いほうが良い

- 処理効率
一定時間にこなせる処理の量
  大きいほうが良い
  資源の利用効率が高いほど向上する
  いかに資源を割当てるか
  - スケジューリング

### ファイル

情報を保存するための基本的かつ重要な機能
管理、ネーミング、作成、消去

### プロセス
ユーザーが依頼した仕事を代行する仮想的な実態

→唯一の能動的に動作する実態:ユーザーの代理
資源に対するアクセス権はプロセスに対して定義する

#### マルチタスキング
プロセスを複数生成し、並列に実行する処理方式
→CPUを切り替えて各プロセスの実行を行う
→実際のCPU数よりも多くのプロセスが並列して動作

#### シングルタスキング
プロセスは新たに生成できない

### マルチプロセシング
実CPUを複数備えたシステムで、同時に個々のCPU上でプログラムを実行させる処理方式
=> 並列処理

### シングルプロセッシング
1つのCPUでプログラムを処理する方式

### OSが管理するもの
- プログラムは必ずOSを通して資源を利用する

例: 相互排除
→共通資源を複数のプログラムが逐次的に使用するように制御すること

エラー処理
→ハードウェアで発生するもの
→処理違反で発生するもの
→無視するのではなく正確で矛盾のない処理を保証する

## 1-3 OSによる仮想化

仮想化: ハードウェア資源の多重化によって、各プログラムに専用の資源があるように見せかけること。
また全体として効率よく扱えるようにすること

- 仮想CPU: 実CPUを時分割で割当する
- 仮想記憶: 記憶装置の多重化
  → 主記憶の大きさは無関係にできる
  → いつも主記憶上にプログラムやデータがあるとはかぎらない

- ファイル
  プログラムやデータを長期的に保存するための仮想的な補助記憶の仕組み

- 仮想的な入出力装置
  人間が使いやすくするための工夫
  
プロセス: 仮想CPU+仮想記憶で実行するプログラム実行そのもの

スレッド: 仮想CPUそのもの

仮想計算機間の通信
-> プロセス同期、プロセス通信

## 1-4 コンピュータの処理形態

処理

- バッチ処理
- 対話処理

### バッチ処理
OSがユーザーからのjobを一括して処理する方式
job(コンピュータに依頼するひとかたまりの仕事)

-> ジョブ制御言語で記述し、プログラムデータとともにシステムに入力

=> 高価なハードウェアを有効に利用するためのシステム
-> 処理時間(ターンアラウンド時間、バッチジョブの入力から結果が出るまでの時間)が求められない処理向き

### 対話処理

ユーザーの指示に対して速やかに応答を返す処理形式
-> 対話的である

=> 応答時間が短いことが要求される

-> 指示は処理の内容と示す名前でパラメータで構成する => コマンドという

-> 端末をコンピュータに接続して使用
-> キーボード、ディスプレイ

-> TSS処理はその代表例
→一大の計算機を複数台のユーザーで共用し、各ユーザーに専用の計算機を利用しているように見せかける処理。
=> 利用者の増加、ジョブの重さで応答性が悪化

### バッチ処理 + 対話処理

端末からジョブを記述して、コマンドによりバッチジョブを起動する
→サブミットという

### パーソナル処理
パソコン（計算資源を独占的に使用）、ワークステーション（小規模単純化できる）などの少人数用のシステムによる処理

### リアルタイム処理

発生する事象に対して、定められた応答時間で処理を行う
→オンライン接続された機器から発生（オンラインリアルタイム処理）
発生事象に対して人間が介在し処理要求する
オンライントランザクション処理、トランザクション

### 分散処理

複数の計算機をネットワークLAN WANで結合し、通信を行いながら処理
→クライント、サーバー構成もその一つ。資源を利用する。資源の管理、共有を支援する。

- 情報、資源の共用
- 可用性、信頼性の向上
- 性能の向上
- スケーラビリティ（規模適応性）

=> ユーザーがネットワークを意識することなく利用できることが重要
= ネットワーク透過性

問題点

- 計算機間の距離による遅延
- ネットワークの機能障害
- セキュリティ

# 2章 ユーザーから見たオペレーティング・システム

## 2-1 コマンドとプログラムの実行

- プログラムの実行: コマンド+パラメータ
  例) ls
      ls -al
      コマンド オプション
- コマンドの入力: コマンドプロンプト表示中に入力できる。コマンドの終わりを表すCRを入力することが必要

- コマンドの実行: コマンドインタプリタにより解析、実行

UNIX: シェル(sh,ch,bash,csh, ...)
MS_DOS: コマンドプロセッサ(COMMAND.COM)
-> OSとユーザー間を仲介するもの 自由に置き換えが可能

- 入出力の切り替えとパイプ
- リダイレクション

入出力先を簡単に切り替え指定できる機能
例 cat test.txt > test2.txt
リダイレクション処理。>> : 追記

- パイプ: 一つの処理結果を別の処理に結合させる機能
  => 複数接続して次々とデータ加工ができる（フィルタの機能）
  
 例 cat log.txt | grep HTTP | grep xxx
 パイプ
 
 標準入力、標準出力を定義してファイルや標準入力でアクセスできるようにすることで実現している。
 
 - コマンドの並行処理とジョブ制御

並行処理

- フォアグランド処理: コマンド、プログラムを対話的に処理
- バックグラウンド処理: 非対話的に処理

ジョブ制御: コマンド、プログラムの中止や停止、バックグラウンドを戻す

- コマンドファイル

一連のコマンド群をファイルに登録しておき、実行させるファイルのこと

UNIX: シェルスクリプト
MS-DOS: バッチファイル => xx.bat

- その他
- ワイルドカード指定
- * は任意の文字列、?は任意の1文字。正規表現という。
- ヒストリ機能
- 入力コマンドの履歴ヒストリを持っていて、再活用できる機能
- エイリアス機能
- コマンドに別名をつける機能
- alias ll "ls -al"

## 2-2 利用の開始と終了

- loginとlogout
- セッション: 利用開始から終了まで

### システムの立ち上げと立ち下げ

立ち上げ時: IPL(Initial Program Loader)を主記憶にロードし、IPLがOSなどをロードして起動
-> 次々にいもづるしきに起動していく、ブートローダーという

- ウォームスタート: 立ち上げ時の状態を回復してスタート
- コールドスタート: 完全な初期状態からスタート

立ち下げ時: ユーザーログイン禁止、ジョブの停止、主記憶、データの退避などを行う
-> 勝手に電源を切ってはいけない

## 2-3 グラフィカルユーザーインターフェース

GUI: グラフィカル機能を駆使したユーザーインターフェース
CUI: キャラクタユーザーインターフェース
-> 視覚に訴えるわかりやすいインターフェースの提供
- マルチウィンドウ: 一つの画面に複数の窓を開いて各々の窓で仕事ができる
- アイコン: 仕事の内容や対象のものを抽象化して表した図柄

表示: ビットマップディスプレイ（ドット単位で表示、制御できるディスプレイ
指示: マウス+キーボード
=> マルチメディアインターフェース: 文字、画像、音声、動画等の多用なメディアを統合したインターフェース

- ウィンドウシステム
マルチウィンドウを実現し、マルチウィンドウを用いたアプリケーションの作成を支援するシステム

表示形態
- タイリング方式: 画面を分割して各々をウィンドウとする（ウィンドウ間の重なりがない）
- オーバーラッピング方式: 自由に大きさや位置を変更できるウィンドウ間の重なり処理が必要

キーボード、マウスからの入力処理

複数のウィンドウが動いているので、どれに対する入力か判断する必要がある
=> ウィンドウ全体を含めて一つの階層で処理
-> すべてのウィンドウとして統一的に処理される

実現方法
- OSに組み込む
- アプリ毎にライブラリに組み込む
- プロセスとして実現し、複数のアプリにサービスする
-> クライアント・サーバ方式

UNIXではXウィンドウが用いられている
-> MITで開発、クライアントサーバ方式を採用

- ユーザーインターフェース構築ツール
サーバーを利用するための共通の土台をライブラリとして提供
-> アプリ側ではサーバーと通信する仕組みを意識せずに利用可能

(XウィンドウではXlibとして提供)
-> 低水準

=> ツールキットかスタイルガイドの利用

## 2-4 日本語処理

### 文字コード

文字を表現するための数値
=> 標準化されていないと混乱する

- ASCIIコード
アメリカで標準化、英大小文字、数字、特殊文字,96字,32字,制御コード

計128文字(7ビット表現)からなる
=> 日本語（漢字）の表現にはあきらかに不足する= 2バイト化

- JIS漢字コード
第一バイト、第二バイトともに7ビットで表現、エスケープシーケンスで文字種を示す

- 拡張JIS漢字コード

日本語文字コードは8ビット目をすべて1とする。エスケープシーケンスが不要
半角カナとコードが重なる

- シフトJIS漢字コード
半角カナを避け、2バイトのうち最初の1バイト目の8ビット目を1にするエスケープシーケンスが不要

- 日本語入力
漢字入力は直接入力できないのでかな漢字変換を用いて入力
(ローマ字で与えるものをローマ字かな漢字変換という)

実現方式
- アプリ毎に実現
- 専用ライブラリ実現
- OSの一部として組み込み
- 専用プロセスでサービス
UNIXではwnn,cannaなど

# 3章プログラム開発とオペレーティング・システム

## 3-1 プログラムのコンパイル

ソースプログラム: プログラミング言語を用いて記述
コンパイラアセンブラ: 高水準言語を機械語、アセンブリ言語に変換
アセンブリ言語を機会に変換
オブジェクトモジュール: モジュールをコンパイルしたもの
リンカ: いくつかのオブジェクトモジュールやライブラリを統合して1つのロードモジュールを生成する
ロードモジュール: ローダによってメモリにロード可能なモジュール
ローダ: ロードモジュールをメモリに配置して実行

- プログラミング処理系

プログラミング言語を処理するシステムの総称(言語処理系ともいう)
- インタプリタ方式
プログラムを変換せずにそのまま解釈、実行する
-> 毎回解釈実行するので実行速度は遅め
- トランスレータ方式
プログラムを機能が等価な低水準言語に変換

### コンパイラの構成

ソースプログラム: コンパイラ等に入力されるプログラム
プリプロセッサ: マクロなどを用いたソースプログラムを完全なソースプログラムとして生成
文句解析: 識別子、定数、演算子、区切り記号などの字句に分解する
構文解析:  構文規則に照らしてプログラムのどの部分がどの構文に対応するか解析する
意味解析: 変数の宣言とその使用との対応付け、データ型の検査を行う
中間コード: オブジェクトコードの作成や最適化、コンパイラの移植を用意にするためのオブジェクトコードよりも水準の高い言語で記述されているコード
最適化: コードを効率よく実行するための操作
コード作成: これらの一連の動作をコンパイルという
オブジェクトコード

## 3-2 プログラムの実行
リンキングとローディング

モジュール ~.c
コンパイル
オブジェクトモジュール ~.o : モジュール外の参照（外部参照という）は名前のまま残しておく
モジュールの先頭を起点とする相対アドレスとして変換
リンキング
ロードモジュール: 複数のオブジェクトモジュールを結合してロードモジュール全体としてのアドレスに変換されている
=> 各オブジェクトモジュールを並べて相対アドレスを変換してまとめる→再配置という
補助記憶装置にファイルとして格納
→プログラムの大きさ、コード、データ、スタックの大きさ、プログラムの実行アドレスなどの情報が付加されている

ローダ: ファイルに格納されたロードモジュールを主記憶に読み込んで実行

1. ファイルを見つけ出す
2. プログラムを実行するプロセスの生成
3. 使用記憶領域の確保
4. プログラムを主記憶上にロード
5. パラメータを渡して実行

- プログラムの構成とサブルーチンコール

コード領域: 命令の列のみ、書き込みがない共用可能
データ領域: 実行中に使用される読み書きがある
スタック領域: サブルーチン呼び出しで戻りアドレスやパラメータの格納を行う領域

### プログラムライブラリ
よく利用されるプログラムを共通して使用できる形にしてあるもの

### プログラムの動的リンキング
プログラム実行中に必要になった時点でモジュールをリンキングする
>- 動的リンクライブラリ: 動的リンキングできるライブラリ
>- 共用ライブラリ: プログラム間で共有できる機能をもつ
>
↔ 最初からすべてのモジュールをリンキング: 静的リンキング

### システムコール

プログラムからOSの提供するサービスを利用するためのインターフェイス

- UNIXでC言語の関数として利用可能
- 汎用大型機ではアセンブリ言語のマクロとして利用可能

例:
>プロセスに関するもの
>ファイルに関するもの
>装置特有の操作
>システム情報を扱うもの
>

## 3-3 プログラミング環境
プログラムの開発過程全般を支援する環境

- エディタ: 対話方式でプログラムを入力、編集する
  - 行エディタ: 行単位で編集
  - スクリーンエディタ: 画面に表示されているものをそのまま編集
  - 構造エディタ: プログラミング言語、文章の構造単位で編集

- デバッガ: プログラムの誤りの発見修整のためのツール
サブルーチンや関数呼び出し、パラメータ、戻値、変数値などの監視
- ステッパ: プログラミング言語の文、関数の実行毎に中断できる
変数、パラメータの表示とセットができる
- インスペクタ: プログラムの実行を中断できる
データ構造の可視化、値のセットができる

### デバッグを補助するツール
- クロスリファレンス
プログラムの中の名前を定義している位置と使用している位置の関係を表示する
- ブラウザ
プログラムのモジュール間の関係やクロスリファレンスの表示
- プリティプリンタ
公文に従って自動的に字下げを行ったり、コメント、予約語の自体を変えて表示

- モジュール間結合管理ツール
モジュールの更新に伴う再コンパイル、リンキングを自動化
Linuxではmakeがある
- ソースプログラム管理ツール名前の長さが記録され、必要な領域が割り当てられる
開発過程における内容をバージョンとして管理 
- ライブラリ管理ツール
複数のモジュールを一つのファイルに格納し、ライブラリ化
- 言語処理系生成ツール
言語の使用を与えて、字句解析(lex)、構文解析(yacc)プログラムを生成する。

# 4章 ファイル
## 4-1 ファイルとは

ファイル: データセットにある情報の集まりを短期・長期的に保存、管理するための入れ物
- 記憶装置上の物理的な領域の割当
- 情報の入出力
- 情報の操作を簡単化するためのインターフェイスの提供
- 複数ユーザーからの利用要求の切り分け
- 必要に応じて共有できる機構の提供

→ ユーザーの便宜を図るための仮想的な記憶装置の提供

## 4-2 ファイルの基本設計

ファイルに格納される情報: ソース、オブジェクト、データ
→ 操作の効率化のためには多くの型をサポート、OSの仕様が巨大化
→ 通常はいくつかの固定した方のファイルをサポート

### ファイルの構造
- 論理レコード: OSが管理する最小の情報の単位。副素手ファイルを構成
- 物理レコード: OSが補助記憶装置との間でやりとりする入出力の単位


- レコード形式のあるもの
固定レコード長、可変レコード長、不定長レコード
- 特定のファイル構造のないもの
  - Unix,MS-DOS: ファイルはバイトの列として扱われる
    - バイト単位の入出力
  - 構造の解釈はOSではなく利用するプログラムが行う

### アクセス法

OSが支援するファイルのアクセス方式のこと
1. 順アクセス: MTなどに整合する
最後にアクセスした位置から読み書きを行う
2. 直接アクセス: ディスク装置などに適合する
アクセス毎に位置を指定、ブロック単位で読み書き

- MVS: ファイル構造に関するアクセス法を用意
順編成、直接編成、索引順編成、区分編成
- Unix: ファイルをバイト列として扱い、入出力を統一して扱う
順アクセス

## 4-3 ユーザーから見たファイルシステム
ファイルシステム: OSによってファイルを標準的な方法で統一的に管理する仕組み

### ディレクトリ
- 名前
- 型
- 物理的な位置
- 大きさ
- 保護情報
- 時刻

### ディレクトリに登録される名前の形式

固定表: 管理しやすい
可変長: 名前の長さが記録され、必要な領域が割り当てられる

### ディレクトリの設計と名前の管理

#### MVS: ボリューム名とファイル名でファイルを特定
物理ボリュームを意識

システム内のファイルの名前を論理的なディレクトリの木に登録
カタログと呼ばれるファイル名の登録簿で管理

#### MS-DOS: ボリュームをドライブ名で指定

ディレクトリにファイル名、型、時刻、FATのインデックス等が登録

#### UNIX: 論理ボリューム毎にディレクトリの木を持つ
ルートファイルシステムに他のファイルシステムの木を結合
ディレクトリはファイルとして実現され、ファイル・下層ディレクトリの名前とiノード番号の対が登録

#### MVS: ボリュームラベルとVtoCにより管理
ボリュームラベル: ボリューム管理情報の見出し ボリューム名とVtoCの記録位置
VtoC: ファイルの管理情報

#### MS-DOS: FAT(File alocation Table)、ルートディレクトリで管理
FAT: ボリューム内の領域管理
ルートディレクトリ: ファイルの名前とファイル管理情報の記録

#### UNIX: スーパーブロックとiノードリストにより管理
スーパーブロック: 1つのボリュームを複数の論理ボリュームとして扱うためのしかけ。論理ボリュームの管理情報が入っている。
iノード: ファイル毎にその管理情報を記録するための一定の大きさのデータ構造、iノード番号により指定される。

### フォーマット

- トラックやセクタのような構造を作成すること 物理フォーマット
- 管理に必要なデータ構造を作成すること 論理フォーマット

### 領域の割り当て

連続した領域に割当する方法

利点

同一または隣接したシリンダの連続した領域の割り当てできればシーク回数を減らしてアクセスを高速化できる
領域の管理が簡単なデータ構造で済む

ファイルの大きさを確定しておく必要がある

領域の割り当てと開放を繰り返すことで外部断片が生じる。


例 アドレス空間の大きさを4バイト
1ブロックの大きさを4kバイト

直接だけ: 4kb * 12 = 48kB
単一間接だけ: ポインタの数 = $\frac{4kB}{4B}=1k$
4kB * 1k = 4MB

二重間接だけ: 4kb * 1k * 1k = 4GB
三十間接だけ: 4kb * 1k * 1k * 1k = 4TB

十分に大きな領域が管理できる。

### 論理ボリュームを隣接したシリンダ領域に分割、管理
シリンダグループ

iノードやデータブロックが近くに置かれる。
アクセス効率の向上

## 4-5 プログラムからのファイル利用

ファイル操作のシステムコール
生成、削除、オープン、クローズ、読み出し、書き込み

### 生成

生成するファイル名などをディレクトリに登録する

### 削除

指定ファイル名のディレクトリからの削除、割り当て領域の開放

### オープン

ファイルに対する読み書きの前にファイルの仕様を宣言する。
アクセスの正当性などを調べ、ファイル操作に必要な情報が高速に索引できるようにデータ構造を作成する。

### クローズ

ファイルアクセスのために用意したデータ構造を開放する。

### 読み出し

ファイルの特定を行い、記憶位置を調べて主記憶上に読み出す。

### 書き込み

ファイルの特定を行い、記憶位置を求めて主記憶のデータを書き出す。

### プログラムとファイルの結合

ファイル制御ブロック(FCB)
プログラム毎にファイルポインタなどの情報を管理するデータ構造

MVS: データ制御ブロックで管理
UNIX: iノード構造体にファイル管理情報を格納し、ファイル構造体にファイルポインタを格納
MS_DOS: ファイルハンドルよる方法、ファイル制御ブロックによる方法

### 入出力ライブラリ

システムコールは基本的な機能だけを提供
入出力機能については、ライブラリとして実現
書式付きの入出力など
