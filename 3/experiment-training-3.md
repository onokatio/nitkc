実験実習 実験3 応用実験(UFO ゲーム)
===


# 1. 目的

H8 マイコンの割り込みについて解を深め、割り込み制御をC言語で記述する方法を学ぶ。当実験では、発展的な課題として「UFOゲーム」作成に取り組み、キー入力処理と効果音処理を割り込みを用いて実現する。

# 2. 使用機器

- H8マイコン
- USBケーブル
- パーソナルコンピュータ

# 3. 実験方法

当課題では、内蔵されているタイマ2つを割り込み発生源として使用する .タイマ0を効果音生成専用のタイマとして割り込み優先度をプライオリティ1 (高優先度) として用いる。プライオリティ1の優先度を使用するためには、UIビットの設定が必要であり、USE_UI(); をプログラムの最初に実行する必要がある。また、タイマ0をプライオリティ1に設定するためには,さらに
```c
timer_pri_set (ch, pri)
```
で設定を行う必要がある。ここで, ch はタイマのチャネル番号, pri はプライスリティ値を示す。割り込みハンドラはint_imia0()であり, sound.c内に記述する。
タイマ1は常に一定間隔 (1[ms])で割り込みを発生し,キーのセンシン進行速度、時間待ち等の処理を行うものとする. 割り込みハンドラは int_imia1()であり、ufo.c に記述する。
課題にあたっては, /home/class/j3/jikken/kouki/no3 以下に課題に必要なファイルを置いてあるので、必ず全てのファイルを各自でコピーして利用すること

## 3.1 課題1 キー読み込みの実装
コピーしたファイル(特に, ufo.c, key.c)をよく読み, key.c に記されている名関数を完成させなさい.
key_sense()はタイマ1の割り込みごとに呼び出され , リングバッファにキーマトリクスの列ごとのスキャンデータを格納するように作成すること。リングバッファはkey.c で大域変数として宣言されている keybuf[p][r] であり, p は参照ポインタ, r は列を表すものとする。また割り込み処理をまたぐリングバッファのポインタはkeybufdp を用いること。なお、キースキャンの方法等については, 最後のページにある補足のキーマトリクスとセンシングを参照のこと.
key_check(keynum)はチャタリング除去を行った結果を返し, 戻り値は key.c で定義されている以下の値;
- KEYOFF 指定キーは押されていない。
- KEYON 指定キーが押されている。
- KEYTRANS 指定キーは変化中。
- KEYNONE 指定キーは存在しない

のいずれかを正しく返すものとする。 また,チャタリング除去で参照するバッファ上の能囲は, key.cで定義されている KEYCHKCOUNT の長さとする.
課題ができたら必ずその時点でコンパイル・実行して動作を確認し,プログラムと動作のチェックを受けること。チェックを受けずに先の課題を行うことは認めないので, 注意すること。
## 3.2 課題2 効果音生成の実装

コピーしたファイル(特に, ufo.cとsound.c)をよく読み, sound.c に記述されている各関数を完成させなさい.

sound_beep (hz, msec, vol)は引数(hz :音高 の 周波数 で単位は[Hz] msec: 音長で単位は[ms], vol :振幅で短形波のD/A上限値)から計算して, 音高生成のための割り込み間隔、音長のための割り込み回数・短形波の振幅を求めて必要な記述を加えること。
sound.c で宣言されている、大域変数timer0_count は割り込み回数格納し、play_countは指定音長に対する割り込み回数を格納 , da-amp は指定振幅を格納するように、各々準備されている。
課題ができたら,必ずその時点でコンパイル・実行して動作を確認し、プログラムと動作のチェックを受けること.チェックを受けすに先の課題を行うことは認めないので注意すること

# 4.実験結果
各実験課題 について,実際の 動作を記述すること . また,課題達成シートを 必ず表紙の次に添付すること.

## 4.1 課題1

キーを押すと、然るべき操作がなされた。
以下にkey.cのソースコードを示す。

ソースコード3.1 key.c
```
#include "h8-3052-iodef.h"
#include "lcd.h"

#define KEYBUFSIZE 10  /* キーバッファの大きさ */
#define KEYCHKCOUNT 5  /* キーの連続状態を調べるバッファ上の長さ　 */
                         /\* ↑キーバッファの大きさよりも小さくすること \*/
                         /\*   余裕が少ないと正しく読めないことがある */
#define KEYROWNUM 4    /* キー配列の列数(縦に並んでいる個数) */
#define KEYCOLNUM 3    /* キー配列の行数(横に並んでいる個数) */
#define KEYMINNUM  1   /* キー番号の最小値 */
#define KEYMAXNUM 12   /* キー番号の最大値 */
#define KEYNONE   -1   /* 指定したキーがない */
#define KEYOFF     0   /* 指定したキーはずっと離されている状態 */
#define KEYON      1   /* 指定したキーはずっと押されている状態 */
#define KEYTRANS   2   /* 指定したキーは遷移状態 */

// キースキャンを行って、状態を調べる関数群
// 一定時間（数ms程度）毎に keysense() を呼び出すことが前提
// 任意のキー状態を読み出すには key_check() を呼び出す

/\* タイマ割り込み処理のため, バッファ関連は大域変数として確保 \*/
/\* これらの変数は key.c 内のみで使用されている               */
int keybufdp; /* キーバッファ参照ポインタ */
unsigned char keybuf\[KEYBUFSIZE\]\[KEYROWNUM\]; /* キーバッファ */

void key_init(void);
void key_sense(void);
int key_check(int keynum);

void key_init(void)
     /\* キーを読み出すために必要な初期化を行う関数 \*/
     /\* PA4-6 が LCD と関連するが, 対策済み       */
{
  int i,j;

  PADR = 0x0f;       /* PA0-3 は0アクティブ, PA4-6 は1アクティブ */
  PADDR = 0x7f;      /* PA0-3 はキーボードマトリクスの出力用 */
                     /\* PA4-6 はLCD制御(E,R/W,RS)の出力用 */
  P6DDR = 0;         /* P60-2 はキーボードマトリクスの入力用 */
                     /\* P63-6 はCPUのバス制御として固定(モード6の時) */
  keybufdp = 0;
  /\* キーバッファのクリア */
  for (i = 0; i < KEYBUFSIZE; i++){
    for (j = 0; j < KEYROWNUM; j++){
      /\* ここで何もキーが押されていない状態にバッファ(keybufdp)を初期化 */
      /\* キーが押されていないときにビットが1となることに注意すること */
		keybuf\[i\]\[j\] = 0xff;
    }
  }
}

void key_sense(void)
     /\* キースキャンしてキーバッファに入れる関数          \*/
     /\*   数ms 程度に一度, タイマ割り込み等で呼び出すこと */
     /\*   大域変数 keybuf はキーデータを格納するバッファ  */
{
  /\* リングバッファポインタ制御 \*/
  /\* ここにバッファポインタ(keybufdp)の更新を書く */
  /\* 　・バッファポインタが最新のスキャンデータを指すようにすること \*/
  /\* 　・リングバッファのつなぎ目の処理を忘れないこと */
	keybufdp++;
	keybufdp %= KEYBUFSIZE;
  /\* キースキャン \*/
  /\* ここでキー列ごとにキースキャンしたデータをそのままキーバッファに格納する \*/
  /\* キー列番号は、0:1〜3の列、1:4〜6の列、2:7〜9の列、3:*〜#の列 とする */
  /\* 各キー列のキーデータは keybuf\[バッファポインタ\]\[キー列番号\] に格納する */
  /\* 　・PA0〜PA3だけを書き換えるように注意すること(他のビットの変化禁止) */
  /\* 　・P60〜P62だけを読むように注意すること(他のビットは0にする) */
    //key 1,2,3
	PADR &= 0xf0;
	PADR |= 0x07;
	keybuf\[keybufdp\]\[0\] = P6DR;   // データ入力

    //key 4,5,6
	PADR &= 0xf0;
	PADR |= 0x0b;
	keybuf\[keybufdp\]\[1\] = P6DR;   // データ入力
      
    //key 7,8,9
	PADR &= 0xf0;
	PADR |= 0x0d;
	keybuf\[keybufdp\]\[2\] = P6DR;   // データ入力
      
    //key *,0,#
	PADR &= 0xf0;
	PADR |= 0x0e;
	keybuf\[keybufdp\]\[3\] = P6DR;   // データ入力
}

int key_check(int keynum)
     /\* キー番号を引数で与えると, キーの状態を調べて返す関数                 \*/
     /\* キー番号(keynum)は 1-12 で指定(回路図の sw1-sw12 に対応)            */
     /\* 基板上の 1-9 のキーは sw1-sw9 に対応している                        */
     /\* 基板上の *,0,# のキーは sw10,sw11,sw12 にそれぞれ対応している       */
     /\* 戻り値は, KEYOFF, KEYON, KEYTRANS, KEYNONE のいずれか              */
     /\* チェック中の割り込みによるバッファ書き換え対策はバッファの大きさで対応 */
{
  int r;
  int i;
  int count = 0;
  int tmp;
  /\* 最初にキー番号の範囲をチェックする */
  if ((keynum < 1) || (keynum > KEYMAXNUM))
    r = KEYNONE; /* キー番号指定が正しくないときはKEYNONEを返す */
  else {
    /\* ここでキー番号からキー列番号とデータのビット位置を求める \*/
    /\* キー列番号がわかると配列の参照ができる \*/
    /\* データのビット位置がわかれば、指定されたキーのON/OFFがわかる */
    /\* ここで宣言された長さ(KEYCHKCOUNT)分だけキーの状態を調べる */
    /\* 　・リングバッファのつなぎ目の処理を忘れないこと \*/
    /\* 　・途中でキースキャン割り込みが生じても矛盾しない処理を行うこと \*/
    /\* 指定キーが全てONならKEYON、全てOFFならKEYOFF、それ以外はKEYTRANS とする*/
	tmp =  keybufdp;

	for(i = 0; i<KEYCHKCOUNT; i++){
		if(~(keybuf\[(tmp - i + KEYBUFSIZE)%KEYBUFSIZE\]\[(keynum-1)/3\]) & 0x01<<((keynum-1)%3)) count++;
	}
  	//lcd_cursor(15,0);                     /* LCD にメッセージ表示 */
   	//lcd_printstr("0" + count);

	if(count == 5){
		r = KEYON;
	}else if(count == 0){
		r = KEYOFF;
	}else{
		r = KEYTRANS;
	}

  }
  return r;
}
```

## 4.2 課題2

設定したとおりの音が再生された。
以下にソースコードを示す。

ソースコード3.2 sound.c
```
#include "h8-3052-iodef.h"
#include "timer.h"
#include "da.h"
#include "h8-3052-int.h"

// 単音を一定時間鳴らすための関数群。
// タイマ0を使って音高の1/2周期で割り込みを起こす。
// 音の長さは割り込み回数をカウントして測る。

void int_imia0(void);

/\* sound.cの中だけで閉じている大域変数、割り込みハンドラ用 */
unsigned int timer0\_count, play\_count;
unsigned char da_amp;

void sound_init(void)
     /\* 音を鳴らすための初期化               \*/
     /\* D/A変換用の初期化とスピーカの切り替え */
{
  da_init();               /* DAの初期化 */
  speaker_switch(SPEAKER); /* スピーカとして使用 */
}

void sound_beep(int hz,int msec,int vol) // 250,200,32
     /\* タイマ0の割り込みを使って単音を一定の長さだけ鳴らすための関数  */
     /\* 引数は、hz:音高, msec:音長, vol:音量                        */
     /\* timer0\_count, play\_cont, da_amp は割り込みハンドラで使用    */
{
    unsigned int int_time;

    timer0_count = 0;      /* 割り込み回数用カウンタの初期化 */

  /\* ここで割り込み周期(単位は\[μs\])を求めて int_time に入れる */
  /\* 割り込み周期は音高周期の半分 */
	int_time = ((1000*1000)/hz); // 2000us

  /\* ここで指定音長となる割り込み回数を求めて play_count に入れる */
  /\* 単位に注意して音長が割り込み何回分かを求める */
	play\_count = (msec*1000)/int\_time; //100

  /\* ここで指定音量になるように da_amp にセットする */
  /\* 割り込みハンドラに渡すために大域変数に入れる */
	da_amp = vol;

    timer\_set(0,int\_time);  /* 音高用割り込み周期のセット */
    timer_start(0);         /* タイマ0スタート */
}

#pragma interrupt
void int_imia0(void)
     /\* 音高を出すための割り込みハンドラ \*/
     /\* 使用する大域変数と役割は以下の通り \*/
     /\*   timer0_count は割り込み回数を数えるカウンタ */
     /\*   play_cont は指定音長になるときの割り込み回数 */
     /\*   da_amp はD/Aの出力上限値  */
{
  /\* ここで、割り込み回数をインクリメントする */
	timer0_count++;

  /\* ここで、割り込みがかかる度にD/Aの出力を上限値か下限値に切替える */
	if(timer0_count%2){
		da\_out(0,da\_amp);
	}else{
		da_out(0,0);
	}

  /\* ここで、タイマカウントが音長カウントに達したらタイマストップする \*/
  /\* タイマストップしたら割り込みはかからなくなる */
	if(timer0\_count > play\_count) timer_stop(0);

  /\* 再びタイマ割り込みを使用するために必要な操作      */
    timer\_intflag\_reset(0);  /* タイマ0の割り込みフラグをクリア */
    ENINT();                 /* CPUを割り込み許可状態に */
}

```

# 5. 検討課題

## 検討課題1
タイマー割り込みとリング・バッファを用いた方法(今回の実験）と割り込みを使わずにチャタリング除去の処理を待ち時により行う方法(前の実験)とを比較し、今回の実験の方式の方が優れている点を考察せよ。

→ 後者は前者と違い待ち時間がないため時間を有効に活用できる点が優れている。

## 検討課題 2
sound.cで実装したような割り込み処理よる効果音生成において,効果音の音書が高くなると,どのような悪影響かじてるかについて検討せよ。

→ 周波数の間隔が割り込み間隔より短くなると、音が再現できなくなる。